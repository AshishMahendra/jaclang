"""First Jac pass bootstrapped in Jac"""
import:py jaclang.jac.absyntree as ast;
import:py from jaclang.jac.passes.blue, BluePygenPass;
import:py from jaclang.core, Object, Node, Edge, Walker, Ability;
import:py from jaclang.jac.lexer, Tokens as Tok;
import:py from jaclang.jac.constant, INIT_FUNC;

object PurplePygenPass:BluePygenPass {

    """ Addd arch import to the preamble """
    can add_arch_import(arch: str);
    """ Addd exec context import to the preamble """
    can add_exec_context();

    can exit_architype(nd: ast.Architype);
}

:object:PurplePygenPass:ability:add_arch_import
(arch: str) {
    (self.preamble, f"from jaclang.core import {arch} as __jac_{arch}__")
    |> <self>.emit_ln_unique;
}

:object:PurplePygenPass:ability:add_exec_context {
    (self.preamble, f"from jaclang.core import exec_ctx as __jac_exec_ctx")
    |> <self>.emit_ln_unique;
}


"""
Sub objects.

name: Name,
arch_type: Token,
doc: Optional[DocString],
decorators: Optional["Decorators"],
access: Optional[Token],
base_classes: "BaseClasses",
body: Optional["ArchBlock"],
"""
:object:PurplePygenPass:ability:exit_architype
(nd: ast.Architype) {
    |> <self>.add_exec_context;
    if nd.decorators {
        (nd, nd.decorators.meta["py_code"]) |> <self>.emit_ln;
    }
    arch_type=nd.arch_type.name;
    arch_insert = "";
    if arch_type == Tok.KW_OBJECT {
        "Object" |> <self>.add_arch_import;
        arch_insert = "__jac_Object__";
    }
    elif arch_type == Tok.KW_NODE {
        "Node" |> <self>.add_arch_import;
        arch_insert = "__jac_Node__";
    }
    elif arch_type == Tok.KW_EDGE {
        "Edge" |> <self>.add_arch_import;
        arch_insert = "__jac_Edge__";
    }
    elif arch_type == Tok.KW_WALKER {
        "Walker" |> <self>.add_arch_import;
        arch_insert = "__jac_Walker__";
    }
    if nd.base_classes.base_classes |> len {
        (nd, f"class {nd.name.meta['py_code']}"
             f"({nd.base_classes.meta['py_code']}, {arch_insert}):")
            |> <self>.emit_ln;
    } else {
        (nd, f"class {nd.name.meta['py_code']}({arch_insert}):") |> <self>.emit_ln;
    }
    if nd.doc {
        (nd, nd.doc.meta["py_code"], indent_delta=1) |> <self>.emit_ln; }
    if nd.body {
        (nd, nd.body.meta["py_code"], indent_delta=1) |> <self>.emit_ln; }
    else {
        nd.name.meta["py_code"] |> <self>.decl_def_missing; }
}


"""Sub objects.

members: list["ArchHas | Ability"],
"""
:object:PurplePygenPass:ability:exit_arch_block
(nd: ast.ArchBlock) {
    init_func = None;
    for i in nd.members {
        if i|>type == ast.Ability and i.name.value == INIT_FUNC {
            init_func = i;
        }
    }
    if init_func and init_func.is_func {
        (nd, f"def __init__(self{init_func.signature.meta['py_code']}:")
            |> <self>.emit_ln;
    } else {
        (nd, "def __init__(self, *args, **kwargs):") |> <self>.emit_ln;
    }
    (nd, '"""Init generated by Jac."""', indent_delta=1) |> <self>.emit_ln;
    for i in nd.members {
        if i|>type == ast.ArchHas and not i.is_static {
            (nd, f"self.has_{i.h_id}()", indent_delta=1) |> <self>.emit_ln;
        }
    }
    if init_func {
        params = [];
        if (init_func.signature|>type == ast.FuncSignature
            and init_func.signature.params) {
            params = [x.name.value for x in init_func.signature.params.params];
        }
        (nd, f"self.{INIT_FUNC}({', '.join(params)})", indent_delta=1)
            |> <self>.emit_ln;
    }
    (nd, "super().__init__(*args, **kwargs)", indent_delta=1) |> <self>.emit_ln;
    for i in nd.members {
        (nd, i.meta["py_code"]) |> <self>.emit_ln;
    }
}