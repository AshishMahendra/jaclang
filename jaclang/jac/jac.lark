start: module

module: (doc_tag? element (element_with_doc | element)*)?
      | doc_tag (element_with_doc (element_with_doc | element)*)?

element_with_doc: doc_tag element

element: py_code_block
       | include_stmt
       | import_stmt
       | ability
       | architype
       | mod_code
       | test
       | global_var

global_var: (KW_FREEZE | KW_GLOBAL) access_tag? assignment_list SEMI
access_tag: COLON ( KW_PROT | KW_PUB | KW_PRIV )
test: KW_TEST NAME? code_block
mod_code: KW_WITH KW_ENTRY sub_name? code_block
doc_tag: ( STRING | DOC_STRING )
py_code_block: PYNLINE

import_stmt: KW_IMPORT sub_name KW_FROM import_path COMMA import_items SEMI
           | KW_IMPORT sub_name import_path KW_AS NAME SEMI
           | KW_IMPORT sub_name import_path SEMI

include_stmt: KW_INCLUDE sub_name import_path SEMI

import_path: DOT? DOT? esc_name ((DOT esc_name)+)?

import_items: (import_items COMMA)? named_refs (KW_AS NAME)?

architype: decorators architype
          | enum
          | architype_def
          | architype_decl

architype_decl: arch_type access_tag? NAME inherited_archs (member_block | SEMI)

architype_def: abil_to_arch_chain member_block

arch_type: KW_WALKER
          | KW_OBJECT
          | KW_EDGE
          | KW_NODE

decorators: (DECOR_OP atom)+

inherited_archs: sub_name_dotted*

sub_name: COLON NAME

sub_name_dotted: COLON dotted_name

dotted_name: all_refs (DOT dotted_name)?

esc_name: KWESC_NAME
         | NAME

all_refs: special_refs
        | named_refs

named_refs: global_ref
           | esc_name

special_refs: INIT_OP
            | ROOT_OP
            | SUPER_OP
            | SELF_OP
            | HERE_OP

enum: enum_def
     | enum_decl

enum_decl: KW_ENUM access_tag? NAME inherited_archs (enum_block | SEMI)

enum_def: arch_to_enum_chain enum_block

enum_block: LBRACE enum_stmt_list? RBRACE

enum_stmt_list: enum_item (COMMA enum_stmt_list)?

enum_item: NAME EQ expression
         | NAME

ability: decorators ability
        | ability_def
        | KW_ASYNC ability_decl
        | ability_decl

ability_decl: KW_STATIC? KW_CAN access_tag? all_refs (func_decl | event_clause) (code_block | SEMI)
ability_def: arch_to_abil_chain (func_decl | event_clause) code_block

abstract_ability: KW_STATIC? KW_CAN access_tag? all_refs (func_decl | event_clause) KW_ABSTRACT SEMI

event_clause: KW_WITH type_spec? (KW_EXIT | KW_ENTRY) return_type_tag?

func_decl: (LPAREN func_decl_param_list? RPAREN)? return_type_tag?

func_decl_param_list: param_var (COMMA func_decl_param_list)?

param_var: (STAR_POW | STAR_MUL)? NAME type_tag (EQ expression)?

member_block: LBRACE member_stmt_list? RBRACE

member_stmt_list: member_stmt (member_stmt_list)?

member_stmt: py_code_block
           | doc_tag? abstract_ability
           | doc_tag? ability
           | doc_tag? architype
           | doc_tag? has_stmt

has_stmt: KW_STATIC? (KW_FREEZE | KW_HAS) access_tag? has_assign_clause SEMI

has_assign_clause: typed_has_clause (COMMA has_assign_clause)?

typed_has_clause: esc_name type_tag (EQ expression)?

type_tag: COLON type_spec

return_type_tag: RETURN_HINT? type_spec

type_spec: single_type (BW_OR type_spec | NULL_OK)?

single_type: TYP_DICT LSQUARE single_type COMMA single_type RSQUARE
           | TYP_SET LSQUARE single_type RSQUARE
           | TYP_TUPLE LSQUARE single_type RSQUARE
           | TYP_LIST LSQUARE single_type RSQUARE
           | dotted_name
           | NULL
           | builtin_type

builtin_type: TYP_TYPE
            | TYP_ANY
            | TYP_BOOL
            | TYP_DICT
            | TYP_SET
            | TYP_TUPLE
            | TYP_LIST
            | TYP_FLOAT
            | TYP_INT
            | TYP_BYTES
            | TYP_STRING

code_block: LBRACE statement_list? RBRACE

statement_list: statement+

statement: py_code_block
          | walker_stmt
          | await_stmt SEMI
          | yield_stmt SEMI
          | return_stmt SEMI
          | report_stmt SEMI
          | delete_stmt SEMI
          | ctrl_stmt SEMI
          | assert_stmt SEMI
          | raise_stmt SEMI
          | with_stmt
          | while_stmt
          | for_stmt
          | try_stmt
          | if_stmt
          | expression SEMI
          | static_assignment
          | assignment SEMI
          | typed_ctx_block
          | doc_tag? ability
          | doc_tag? architype
          | import_stmt

typed_ctx_block: RETURN_HINT type_spec code_block

if_stmt: KW_IF expression code_block (elif_list? else_stmt? | elif_list?)

elif_list: KW_ELIF expression code_block elif_list?

else_stmt: KW_ELSE code_block

try_stmt: KW_TRY code_block (except_list? finally_stmt? | finally_stmt)

except_list: except_def+

except_def: KW_EXCEPT expression (KW_AS NAME)? code_block

finally_stmt: KW_FINALLY code_block

for_stmt: KW_FOR (name_list KW_IN | assignment KW_TO expression KW_BY) expression code_block

name_list: NAME (COMMA name_list)?

while_stmt: KW_WHILE expression code_block

with_stmt: KW_WITH expr_as_list code_block

expr_as_list: (expression (KW_AS NAME)?) (COMMA expr_as_list)?

raise_stmt: KW_RAISE expression?

assert_stmt: KW_ASSERT expression (COMMA expression)?

ctrl_stmt: KW_SKIP | KW_BREAK | KW_CONTINUE

delete_stmt: KW_DELETE expression

report_stmt: KW_REPORT expression

return_stmt: KW_RETURN expression?

yield_stmt: KW_YIELD expression?

walker_stmt: disengage_stmt | revisit_stmt | visit_stmt | ignore_stmt

ignore_stmt: KW_IGNORE expression SEMI

visit_stmt: KW_VISIT (sub_name_dotted)? expression (else_stmt | SEMI)

revisit_stmt: KW_REVISIT expression? (else_stmt | SEMI)

disengage_stmt: KW_DISENGAGE SEMI

await_stmt: KW_AWAIT expression

assignment: KW_FREEZE? atom EQ expression

static_assignment: KW_HAS assignment_list SEMI

expression: pipe KW_IF expression KW_ELSE expression
          | pipe

pipe: pipe_back PIPE_FWD pipe
    | pipe_back

pipe_back: elvis_check PIPE_BKWD pipe_back
         | elvis_check

elvis_check: bitwise_or ELVIS_OP elvis_check
           | bitwise_or

bitwise_or: bitwise_xor BW_OR bitwise_or
          | bitwise_xor

bitwise_xor: bitwise_and BW_XOR bitwise_xor
           | bitwise_and

bitwise_and: shift BW_AND bitwise_and
           | shift

shift: logical RSHIFT shift
     | logical LSHIFT shift
     | logical

logical: NOT logical
       | compare KW_OR logical
       | compare KW_AND logical
       | compare

compare: arithmetic cmp_op compare
       | arithmetic

arithmetic: term MINUS arithmetic
          | term PLUS arithmetic
          | term

term: factor MOD term
    | factor DIV term
    | factor FLOOR_DIV term
    | factor STAR_MUL term
    | factor

factor: power
      | BW_NOT factor
      | MINUS factor
      | PLUS factor

power: connect STAR_POW power
     | connect

connect: atomic_pipe
       | atomic_pipe connect_op connect
       | atomic_pipe disconnect_op connect

atomic_pipe: atomic_pipe_back
           | atomic_pipe KW_SPAWN atomic_pipe_back
           | atomic_pipe A_PIPE_FWD atomic_pipe_back

atomic_pipe_back: unpack
                | atomic_pipe_back A_PIPE_BKWD unpack

unpack: ref
      | STAR_MUL atom
      | STAR_POW atom

ref: walrus_assign
   | BW_AND walrus_assign

walrus_assign: ds_call walrus_op walrus_assign
             | ds_call

ds_call: atom
       | PIPE_FWD atom
       | A_PIPE_FWD atom
       | KW_SPAWN atom

walrus_op: RSHIFT_EQ
         | LSHIFT_EQ
         | BW_NOT_EQ
         | BW_XOR_EQ
         | BW_OR_EQ
         | BW_AND_EQ
         | MOD_EQ
         | DIV_EQ
         | FLOOR_DIV_EQ
         | MUL_EQ
         | SUB_EQ
         | ADD_EQ
         | WALRUS_EQ

cmp_op: KW_ISN
      | KW_IS
      | KW_NIN
      | KW_IN
      | NE
      | GTE
      | LTE
      | GT
      | LT
      | EE

atom: edge_op_ref
    | all_refs
    | atomic_chain
    | LPAREN expression RPAREN
    | atom_collection
    | atom_literal

atom_literal: builtin_type
            | NULL
            | BOOL
            | multistring
            | FLOAT
            | OCT
            | BIN
            | HEX
            | INT

atom_collection: dict_compr
               | set_compr
               | gen_compr
               | list_compr
               | dict_val
               | set_val
               | tuple_val
               | list_val

multistring: multistring fstring
           | multistring STRING
           | fstring
           | STRING

fstring: FSTR_START fstr_parts* FSTR_END

fstr_parts: FSTR_PIECE
          | FSTR_BESC
          | fstr_expr
          | fstring

fstr_expr: LBRACE expression RBRACE

list_val: LSQUARE expr_list? RSQUARE
tuple_val: LPAREN tuple_list? RPAREN
set_val: LBRACE expr_list RBRACE

expr_list: expr_list COMMA expression | expression

tuple_list: expression COMMA (expr_list COMMA assignment_list | assignment_list | expr_list)?
          | assignment_list
          | expression COMMA

dict_val: LBRACE kv_pairs? RBRACE

list_compr: LSQUARE inner_compr RSQUARE
gen_compr: LPAREN inner_compr RPAREN
set_compr: LBRACE inner_compr RBRACE
inner_compr: expression KW_FOR name_list KW_IN walrus_assign (KW_IF expression)?

dict_compr: LBRACE expression COLON expression KW_FOR name_list KW_IN walrus_assign (KW_IF expression)? RBRACE

kv_pairs: (expression COLON expression COMMA)* expression COLON expression

atomic_chain: atomic_call
            | atomic_chain_unsafe
            | atomic_chain_safe

atomic_chain_unsafe: atom (filter_compr | edge_op_ref | index_slice | DOT_BKWD all_refs | DOT_FWD all_refs | DOT all_refs)

atomic_chain_safe: atom NULL_OK (filter_compr | edge_op_ref | index_slice | DOT_BKWD all_refs | DOT_FWD all_refs | DOT all_refs)

atomic_call: atom func_call_tail

func_call_tail: LPAREN param_list? RPAREN

param_list: (expr_list COMMA assignment_list) | assignment_list | expr_list

assignment_list: assignment_list COMMA assignment | assignment

index_slice: LSQUARE expression? (COLON expression?)? RSQUARE

arch_ref: object_ref
        | walker_ref
        | edge_ref
        | node_ref

arch_or_ability_chain: (arch_or_ability_chain (ability_ref | arch_ref)) | ability_ref | arch_ref

abil_to_arch_chain: arch_or_ability_chain arch_ref | arch_ref

arch_to_abil_chain: arch_or_ability_chain ability_ref | ability_ref

arch_to_enum_chain: arch_or_ability_chain enum_ref | enum_ref

node_ref: NODE_OP NAME
edge_ref: EDGE_OP NAME
walker_ref: WALKER_OP NAME
object_ref: OBJECT_OP esc_name
enum_ref: ENUM_OP NAME
ability_ref: ABILITY_OP (special_refs | esc_name)
global_ref: GLOBAL_OP esc_name

edge_op_ref: edge_any
           | edge_from
           | edge_to

edge_to: ARROW_R_P1 expression (COLON filter_compare_list)? ARROW_R_P2
       | ARROW_R

edge_from: ARROW_L_P1 expression (COLON filter_compare_list)? ARROW_L_P2
         | ARROW_L

edge_any: ARROW_L_P1 expression (COLON filter_compare_list)? ARROW_R_P2
        | ARROW_BI

connect_op: connect_from
          | connect_to

disconnect_op: NOT edge_op_ref

connect_to: CARROW_R_P1 expression (COLON assignment_list)? CARROW_R_P2
          | CARROW_R

connect_from: CARROW_L_P1 expression (COLON assignment_list)? CARROW_L_P2
            | CARROW_L

filter_compr: LPAREN EQ filter_compare_list RPAREN

filter_compare_list: (esc_name cmp_op expression COMMA)* esc_name cmp_op expression

FLOAT: /(\d+(\.\d*)?|\.\d+)([eE][+-]?\d+)?/
DOC_STRING: /"""(.|\n|\r)*?"""|'''(.|\n|\r)*?'''/
PYNLINE: /::py::(.|\n|\r)*?::py::/
STRING: /"[^"\r\n]*"|'[^'\r\n]*'/
BOOL: /True|False/
KW_NIN: /\bnot\s+in\b/
KW_ISN: /\bis\s+not\b/
HEX: /0[xX][0-9a-fA-F_]+/
BIN: /0[bB][01_]+/
OCT: /0[oO][0-7_]+/
INT: /[0-9][0-9_]*/
NULL: /None/
KWESC_NAME: /<>[a-zA-Z_][a-zA-Z0-9_]*/
NAME: /[a-zA-Z_][a-zA-Z0-9_]*/

TYP_STRING: "str"
TYP_INT: "int"
TYP_FLOAT: "float"
TYP_LIST: "list"
TYP_TUPLE: "tuple"
TYP_SET: "set"
TYP_DICT: "dict"
TYP_BOOL: "bool"
TYP_BYTES: "bytes"
TYP_ANY: "any"
TYP_TYPE: "type"
KW_FREEZE: "froz"
KW_ABSTRACT: "abstract"
KW_OBJECT: "object"
KW_ENUM: "enum"
KW_NODE: "node"
KW_IGNORE: "ignore"
KW_VISIT: "visit"
KW_REVISIT: "revisit"
KW_SPAWN: "spawn"
KW_WITH: "with"
KW_ENTRY: "entry"
KW_EXIT: "exit"
KW_IMPORT: "import"
KW_INCLUDE: "include"
KW_FROM: "from"
KW_AS: "as"
KW_EDGE: "edge"
KW_WALKER: "walker"
KW_ASYNC: "async"
KW_AWAIT: "await"
KW_TEST: "test"
KW_ASSERT: "assert"
KW_IF: "if"
KW_ELIF: "elif"
KW_ELSE: "else"
KW_FOR: "for"
KW_TO: "to"
KW_BY: "by"
KW_WHILE: "while"
KW_CONTINUE: "continue"
KW_BREAK: "break"
KW_DISENGAGE: "disengage"
KW_YIELD: "yield"
KW_SKIP: "skip"
KW_REPORT: "report"
KW_RETURN: "return"
KW_DELETE: "del"
KW_TRY: "try"
KW_EXCEPT: "except"
KW_FINALLY: "finally"
KW_RAISE: "raise"
KW_IN: "in"
KW_IS: "is"
KW_PRIV: "private"
KW_PUB: "public"
KW_PROT: "protected"
KW_HAS: "has"
KW_GLOBAL: "global"
KW_CAN: "can"
KW_STATIC: "static"

ARROW_L: /<--/
ARROW_R: /-->/
ARROW_BI: /<-->/
ARROW_L_P1: /<-\[/
ARROW_R_P2: /]->/
ARROW_L_P2: /]-/
ARROW_R_P1: /-\[/
CARROW_L: /<\+\+/
CARROW_R: /\+\+>/
CARROW_L_P1: /<\+\[/
CARROW_R_P2: /]\+>/
CARROW_L_P2: /]\+/
CARROW_R_P1: /\+\[/

GLOBAL_OP: /:g:|:global:/
HERE_OP: /<h>|<here>/
SELF_OP: /<s>|<self>/
INIT_OP: /<i>|<init>/
SUPER_OP: /<super>/
ROOT_OP: /<r>|<root>/
WALKER_OP: /:w:|:walker:/
NODE_OP: /:n:|:node:/
EDGE_OP: /:e:|:edge:/
OBJECT_OP: /:o:|:object:/
ENUM_OP: /:enum:/
ABILITY_OP: /:a:|:ability:/
A_PIPE_FWD: /:>/
A_PIPE_BKWD: /<:/
PIPE_FWD: /\|>/
PIPE_BKWD: /<\|/
DOT_FWD: /\.>/
DOT_BKWD: /<\./
RETURN_HINT: /->/
ELVIS_OP: /\?:/
NULL_OK: /\?/
DECOR_OP: /@/

KW_AND: /&&|and/
KW_OR:  /\|\||or/
ADD_EQ: /\+=/
SUB_EQ: /-=/
MUL_EQ: /\*=/
FLOOR_DIV_EQ: /\/\/=/
DIV_EQ: /\/=/
MOD_EQ: /%=/
BW_AND_EQ: /&=/
BW_OR_EQ: /\|=/
BW_XOR_EQ: /\^=/
BW_NOT_EQ: /~=/
LSHIFT_EQ: /<<=/
RSHIFT_EQ: />>=/
LSHIFT: /<</
RSHIFT: />>/
LTE: /<=/
GTE: />=/
NE: /!=/
NOT.1: /!|not/
WALRUS_EQ: /:=/
COLON: /:/
LBRACE: /{/
RBRACE: /}/
SEMI: /;/
EE: /==/
EQ: /=/
DOT: /\./
LT: /</
GT: />/
COMMA: /,/
PLUS: /\+/
MINUS: /-/
STAR_POW: /\*\*/
STAR_MUL: /\*/
FLOOR_DIV: /\/\//
DIV: /\//
MOD: /%/
BW_AND: /&/
BW_OR: /\|/
BW_XOR: /\^/
BW_NOT: /~/
LPAREN: /\(/
RPAREN: /\)/
LSQUARE: /\[/
RSQUARE: /\]/

COMMENT: /#\*(.|\n|\r)*?\*#|#.*/
WS: /[ \t\f\r\n]/+

// f-string tokens
FSTR_START.1: "f\""
FSTR_END: "\""
FSTR_PIECE.-1: /[^\{\}\"]+/
FSTR_BESC.1: /{{|}}/

%ignore COMMENT
%ignore WS